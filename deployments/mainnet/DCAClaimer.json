{
  "address": "0x3615d545897E8a34BEE70B7F18fA6c3D23A7730F",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "contract DCA",
          "name": "dca",
          "type": "address"
        },
        {
          "internalType": "address[]",
          "name": "userAddresses",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "indexes",
          "type": "uint256[]"
        }
      ],
      "name": "claimSwappedAmounts",
      "outputs": [
        {
          "internalType": "bool[]",
          "name": "",
          "type": "bool[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "emergency",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x584febe76d163dafc060099ae37c9a02a0e3d6aafdbdabda264973f29668cfb2",
  "receipt": {
    "to": null,
    "from": "0xe59f139acBAB76d41623870F89f107d26Cf1E2B8",
    "contractAddress": "0x3615d545897E8a34BEE70B7F18fA6c3D23A7730F",
    "transactionIndex": 1,
    "gasUsed": "841643",
    "logsBloom": "0x00000000000000000000000000000000000000004000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000002000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000001000000000002000000000000000000000000004000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0bb550b5fdfd306440ee1210884e146de666416eea491383074cb63ce3b8a7b5",
    "transactionHash": "0x584febe76d163dafc060099ae37c9a02a0e3d6aafdbdabda264973f29668cfb2",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 14039244,
        "transactionHash": "0x584febe76d163dafc060099ae37c9a02a0e3d6aafdbdabda264973f29668cfb2",
        "address": "0x3615d545897E8a34BEE70B7F18fA6c3D23A7730F",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000e59f139acbab76d41623870f89f107d26cf1e2b8"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x0bb550b5fdfd306440ee1210884e146de666416eea491383074cb63ce3b8a7b5"
      }
    ],
    "blockNumber": 14039244,
    "cumulativeGasUsed": "868023",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 4,
  "solcInputHash": "5b6f734bcbab792d91e929c8bc0df9da",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract DCA\",\"name\":\"dca\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"userAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"indexes\",\"type\":\"uint256[]\"}],\"name\":\"claimSwappedAmounts\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"emergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"emergency(address)\":{\"notice\":\"Shouldn't be necessary, just in case of emergency\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/DCAClaimer.sol\":\"DCAClaimer\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0xe68ed7fb8766ed1e888291f881e36b616037f852b37d96877045319ad298ba87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\",\"keccak256\":\"0xc995bddbca1ae19788db9f8b61e63385edd3fddf89693b612d5abd1a275974d2\",\"license\":\"MIT\"},\"contracts/DCA.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"./interfaces/ISwapper.sol\\\";\\nimport \\\"./interfaces/IOracle.sol\\\";\\n\\n/// @title DCA\\n/// This contract allows users to deposit one token and gradually swaps it for another one\\n/// every day at the price it's trading at, allowing user to buy the target token using a\\n/// Dollar-Cost Averaging (DCA) strategy.\\n/// @dev To perform the swaps, we aggregate the tokens for all the users and make one big\\n/// swap instead of many small ones.\\ncontract DCA is Ownable {\\n    /// Number of blocks in a day assuming 5 seconds per block. Works for the Celo blockchain.\\n    uint256 public constant BLOCKS_PER_DAY = 17280;\\n    /// Upper limit of the fee that can be charged on swaps. Has to be divided by\\n    /// |FEE_DENOMINATOR|. Equivalent to 60bps.\\n    uint256 public constant MAX_FEE_NUMERATOR = 6_000;\\n    uint256 public constant FEE_DENOMINATOR = 1_000_000;\\n\\n    event OrderCreated(\\n        address indexed userAddress,\\n        uint256 index,\\n        IERC20 indexed sellToken,\\n        IERC20 indexed buyToken,\\n        uint256 amountPerSwap,\\n        uint256 numberOfSwaps,\\n        uint256 startingPeriod\\n    );\\n    event SwapExecuted(\\n        address indexed sellToken,\\n        address indexed buyToken,\\n        uint256 sellAmount,\\n        uint256 buyAmount,\\n        uint256 indexed period\\n    );\\n    /// Emitted when a user withdraws the funds that were already swapped.\\n    event SwappedWithdrawal(\\n        address indexed userAddress,\\n        uint256 indexed index,\\n        address indexed token,\\n        uint256 amount\\n    );\\n    /// Emitted when a user withdraws their principal early. ie. before it was swapped.\\n    event RemainingWithdrawal(\\n        address indexed userAddress,\\n        uint256 indexed index,\\n        address indexed token,\\n        uint256 amount\\n    );\\n    event TokenPairInitialized(address sellToken, address buyToken);\\n    event EmergencyWithdrawal(address token, uint256 amount, address to);\\n    event OracleUpdaterChanged(address oracleUpdater);\\n    event OracleSet(address oracle);\\n    event BeneficiarySet(address newBeneficiary);\\n    event UpdateFeeNumerator(uint256 feeNumerator, uint256 protocolFeePercent);\\n\\n    /// Contains information about one specific user order.\\n    /// A period is defined as a block number divided by |BLOCKS_PER_DAY|.\\n    struct UserOrder {\\n        IERC20 sellToken;\\n        IERC20 buyToken;\\n        uint256 amountPerSwap;\\n        uint256 numberOfSwaps;\\n        uint256 startingPeriod;\\n        uint256 lastPeriodWithdrawal;\\n    }\\n\\n    /// Contains information about the swapping status of a token pair.\\n    struct SwapState {\\n        uint256 amountToSwap;\\n        uint256 lastSwapPeriod;\\n    }\\n\\n    /// For a given (sellToken, buyToken, period) tuple it returns the exchange rate used (if\\n    /// the period is in the past), how many daily swap tokens have their last day on that period\\n    /// and the fee charged in the period if it's in the past.\\n    struct PeriodSwapState {\\n        /// For each past period, what exchange rate was used.\\n        uint256 exchangeRate;\\n        /// For each future period, how much to reduce to |amountToSwap| in its SwapState.\\n        uint256 amountToReduce;\\n        /// For past periods, the fee numerator used on the swap.\\n        uint256 feeNumerator;\\n    }\\n\\n    /// Contains the state of a token pair swaps. For a given (sellToken, buyToken)\\n    /// it contains how much it should swap in the next period and when the last period was.\\n    mapping(address => mapping(address => SwapState)) public swapStates;\\n    /// Contains information related to swaps for a (sellToken, buyToken, period) tuple.\\n    /// See |PeriodSwapState| for more info.\\n    mapping(address => mapping(address => mapping(uint256 => PeriodSwapState)))\\n        public periodsSwapStates;\\n    /// A list of |UserOrder| for each user address.\\n    mapping(address => UserOrder[]) public orders;\\n\\n    /// Active fees on swaps. To be used together with |FEE_DENOMINATOR|.\\n    uint256 public feeNumerator;\\n    /// |protocolFeeNumerator| / 100 of the fee will be sent to the treasury and the rest to the swapper.\\n    uint256 public protocolFeePercent;\\n    /// Where to send the fees.\\n    address public beneficiary;\\n    /// Oracle to use to get the amount to receive on swaps.\\n    Oracle public oracle;\\n    /// If true, the owner can withdraw funds. Should be turned off after there is sufficient confidence\\n    /// in the code, for example after audits.\\n    bool public guardrailsOn;\\n    /// Address that can update the oracle. Matches the owner at first, but should be operated by the\\n    /// community after a while.\\n    address public oracleUpdater;\\n\\n    /// @dev Throws if called by any account other than the oracle updater.\\n    modifier onlyOracleUpdater() {\\n        require(\\n            oracleUpdater == msg.sender,\\n            \\\"DCA: caller is not the oracle updater\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        Oracle _oracle,\\n        address _beneficiary,\\n        uint256 initialFeeNumerator,\\n        uint256 initialProtocolFeePercent\\n    ) {\\n        guardrailsOn = true;\\n        oracleUpdater = msg.sender;\\n        setOracle(_oracle);\\n        setBeneficiary(_beneficiary);\\n        setFeeNumerator(initialFeeNumerator, initialProtocolFeePercent);\\n    }\\n\\n    /// Starts a new DCA position for the |msg.sender|. When creating a new position, we\\n    /// add the |_amountPerSwap| to the |amountToSwap| variable on |SwapState| and to\\n    /// |amountToReduce| on the final period's |PeriodSwapState|. Thus, the amount to swap\\n    /// daily will increase between the current period and the final one.\\n    /// @param _sellToken token to sell on each period.\\n    /// @param _buyToken token to buy on each period.\\n    /// @param _amountPerSwap amount of _sellToken to sell each period.\\n    /// @param _numberOfSwaps number of periods to do the swapping.\\n    function createOrder(\\n        IERC20 _sellToken,\\n        IERC20 _buyToken,\\n        uint256 _amountPerSwap,\\n        uint256 _numberOfSwaps\\n    ) external returns (uint256 index) {\\n        require(\\n            _sellToken.transferFrom(\\n                msg.sender,\\n                address(this),\\n                _amountPerSwap * _numberOfSwaps\\n            ),\\n            \\\"DCA: Not enough funds\\\"\\n        );\\n\\n        SwapState storage swapState = swapStates[address(_sellToken)][\\n            address(_buyToken)\\n        ];\\n        // If it's the first order for this pair, initialize it.\\n        if (swapState.lastSwapPeriod == 0) {\\n            swapState.lastSwapPeriod = getCurrentPeriod() - 1;\\n            emit TokenPairInitialized(address(_sellToken), address(_buyToken));\\n        }\\n        uint256 startingPeriod = swapState.lastSwapPeriod + 1;\\n        UserOrder memory newOrder = UserOrder(\\n            _sellToken,\\n            _buyToken,\\n            _amountPerSwap,\\n            _numberOfSwaps,\\n            startingPeriod,\\n            swapState.lastSwapPeriod\\n        );\\n\\n        swapState.amountToSwap += _amountPerSwap;\\n        periodsSwapStates[address(_sellToken)][address(_buyToken)][\\n            startingPeriod + _numberOfSwaps - 1\\n        ].amountToReduce += _amountPerSwap;\\n\\n        index = orders[msg.sender].length;\\n        orders[msg.sender].push(newOrder);\\n\\n        emit OrderCreated(\\n            msg.sender,\\n            index,\\n            _sellToken,\\n            _buyToken,\\n            _amountPerSwap,\\n            _numberOfSwaps,\\n            startingPeriod\\n        );\\n    }\\n\\n    /// Executes a swap between two tokens. The period must be the last executed + 1.\\n    /// The swapping is done by the |_swapper|. We calculate the required exchange rate using\\n    /// an oracle, send them the funds to swap and expect them to return the calculated return\\n    /// amount. This allows us to more easily add pairs since we just need the oracle support,\\n    /// not the exact routes to follow. Callers are incentivized to call this function for\\n    /// the arbitrage opportunity.\\n    ///\\n    /// In other words, the general logic followed here is:\\n    /// - Calculate and send the fee to the |beneficiary|.\\n    /// - Calculate the exchange rate using |oracle|.\\n    /// - Send the swap amount to |_swapper| can call its |swap| function.\\n    /// - Check that it returned the required funds taking the exchange rate into account.\\n    /// @param _sellToken token to sell on the swap.\\n    /// @param _buyToken token to buy on the swap.\\n    /// @param _period period to perform the swap for. It has only one possible valid\\n    /// value, so it is not strictly necessary.\\n    /// @param _swapper address that will perform the swap.\\n    /// @param _params params to send to |_swapper| for performing the swap.\\n    function executeOrder(\\n        address _sellToken,\\n        address _buyToken,\\n        uint256 _period,\\n        address _swapper,\\n        bytes memory _params\\n    ) external {\\n        SwapState storage swapState = swapStates[_sellToken][_buyToken];\\n        require(swapState.lastSwapPeriod + 1 == _period, \\\"DCA: Invalid period\\\");\\n        require(\\n            _period <= getCurrentPeriod(),\\n            \\\"DCA: Period cannot be in the future\\\"\\n        );\\n        uint256 totalFee = (swapState.amountToSwap * feeNumerator) /\\n            FEE_DENOMINATOR;\\n        uint256 protocolFee = (totalFee * protocolFeePercent) / 100;\\n        uint256 swapperFee = totalFee - protocolFee;\\n        uint256 swapAmount = swapState.amountToSwap - protocolFee - swapperFee;\\n\\n        uint256 requiredAmount = oracle.consult(\\n            _sellToken,\\n            swapAmount,\\n            _buyToken\\n        );\\n        require(requiredAmount > 0, \\\"DCA: Oracle failure\\\");\\n\\n        PeriodSwapState storage periodSwapState = periodsSwapStates[_sellToken][\\n            _buyToken\\n        ][_period];\\n\\n        swapState.lastSwapPeriod++;\\n        swapState.amountToSwap -= periodSwapState.amountToReduce;\\n        periodSwapState.exchangeRate = (requiredAmount * 1e27) / swapAmount;\\n        periodSwapState.feeNumerator = feeNumerator;\\n\\n        require(\\n            IERC20(_sellToken).transfer(beneficiary, protocolFee),\\n            \\\"DCA: Fee transfer to beneficiary failed\\\"\\n        );\\n\\n        uint256 balanceBefore = IERC20(_buyToken).balanceOf(address(this));\\n        require(\\n            IERC20(_sellToken).transfer(_swapper, swapAmount + swapperFee),\\n            \\\"DCA: Transfer to Swapper failed\\\"\\n        );\\n        ISwapper(_swapper).swap(\\n            _sellToken,\\n            _buyToken,\\n            swapAmount,\\n            requiredAmount,\\n            _params\\n        );\\n        require(\\n            balanceBefore + requiredAmount <=\\n                IERC20(_buyToken).balanceOf(address(this)),\\n            \\\"DCA: Not enough balance returned\\\"\\n        );\\n\\n        emit SwapExecuted(\\n            _sellToken,\\n            _buyToken,\\n            swapAmount,\\n            requiredAmount,\\n            _period\\n        );\\n    }\\n\\n    /// Withdraw the funds that were already swapped.\\n    /// @param userAddress the user to withdraw for.\\n    /// @param index the index of the |orders| array for |userAddress|.\\n    function withdrawSwapped(address userAddress, uint256 index) public {\\n        UserOrder storage order = orders[userAddress][index];\\n        (\\n            uint256 amountToWithdraw,\\n            uint256 finalPeriod\\n        ) = calculateAmountToWithdraw(order);\\n        order.lastPeriodWithdrawal = finalPeriod;\\n\\n        require(\\n            order.buyToken.transfer(userAddress, amountToWithdraw),\\n            \\\"DCA: Not enough funds to withdraw\\\"\\n        );\\n\\n        emit SwappedWithdrawal(\\n            userAddress,\\n            index,\\n            address(order.buyToken),\\n            amountToWithdraw\\n        );\\n    }\\n\\n    /// Withdraw the funds that were already swapped for the caller user AND the\\n    /// funds that were not swapped yet, effectively terminating the position.\\n    /// @param index the index of the |orders| array for msg.sender.\\n    function withdrawAll(uint256 index) external {\\n        withdrawSwapped(msg.sender, index);\\n\\n        UserOrder storage order = orders[msg.sender][index];\\n        SwapState storage swapState = swapStates[address(order.sellToken)][\\n            address(order.buyToken)\\n        ];\\n\\n        uint256 finalPeriod = order.startingPeriod + order.numberOfSwaps - 1;\\n\\n        if (finalPeriod > swapState.lastSwapPeriod) {\\n            PeriodSwapState storage finalPeriodSwapState = periodsSwapStates[\\n                address(order.sellToken)\\n            ][address(order.buyToken)][finalPeriod];\\n\\n            swapState.amountToSwap -= order.amountPerSwap;\\n            finalPeriodSwapState.amountToReduce -= order.amountPerSwap;\\n            uint256 amountToWithdraw = order.amountPerSwap *\\n                (finalPeriod - swapState.lastSwapPeriod);\\n            order.lastPeriodWithdrawal = finalPeriod;\\n\\n            require(\\n                order.sellToken.transfer(msg.sender, amountToWithdraw),\\n                \\\"DCA: Not enough funds to withdraw\\\"\\n            );\\n\\n            emit RemainingWithdrawal(\\n                msg.sender,\\n                index,\\n                address(order.sellToken),\\n                amountToWithdraw\\n            );\\n        }\\n    }\\n\\n    function turnOffGuardrails() external onlyOwner {\\n        guardrailsOn = false;\\n    }\\n\\n    /// In case of emergency, in the beginning the owner can remove the funds to return them to users.\\n    /// Should be turned off before receiving any meaningful deposits by calling |turnOffGuardrails|.\\n    function emergencyWithdrawal(IERC20 token, address to) external onlyOwner {\\n        require(guardrailsOn, \\\"DCA: Guardrails are off\\\");\\n        uint256 balance = token.balanceOf(address(this));\\n        require(token.transfer(to, balance), \\\"DCA: Emergency transfer failed\\\");\\n        emit EmergencyWithdrawal(address(token), balance, to);\\n    }\\n\\n    /// Change the address that can update the oracle.\\n    function setOracleUpdater(address _newOracleUpdater)\\n        external\\n        onlyOracleUpdater\\n    {\\n        oracleUpdater = _newOracleUpdater;\\n        emit OracleUpdaterChanged(_newOracleUpdater);\\n    }\\n\\n    /// Update the oracle\\n    function setOracle(Oracle _newOracle) public onlyOracleUpdater {\\n        oracle = _newOracle;\\n        emit OracleSet(address(oracle));\\n    }\\n\\n    /// Update the beneficiary\\n    function setBeneficiary(address _beneficiary) public onlyOwner {\\n        beneficiary = _beneficiary;\\n        emit BeneficiarySet(_beneficiary);\\n    }\\n\\n    /// Update the fee\\n    function setFeeNumerator(uint256 _feeNumerator, uint256 _protocolFeePercent)\\n        public\\n        onlyOwner\\n    {\\n        require(_feeNumerator <= MAX_FEE_NUMERATOR, \\\"DCA: Fee too high\\\");\\n        feeNumerator = _feeNumerator;\\n        protocolFeePercent = _protocolFeePercent;\\n        emit UpdateFeeNumerator(feeNumerator, protocolFeePercent);\\n    }\\n\\n    // From here to the bottom of the file are the view calls.\\n\\n    /// Calculates hoy much |buyToken| is available to withdraw for a user order.\\n    /// Takes into account previous withdrawals and fee taken.\\n    function calculateAmountToWithdraw(UserOrder memory order)\\n        public\\n        view\\n        returns (uint256 amountToWithdraw, uint256 finalPeriod)\\n    {\\n        SwapState memory swapState = swapStates[address(order.sellToken)][\\n            address(order.buyToken)\\n        ];\\n        finalPeriod = Math.min(\\n            swapState.lastSwapPeriod,\\n            order.startingPeriod + order.numberOfSwaps - 1\\n        );\\n        amountToWithdraw = 0;\\n        for (\\n            uint256 period = order.lastPeriodWithdrawal + 1;\\n            period <= finalPeriod;\\n            period++\\n        ) {\\n            PeriodSwapState memory periodSwapState = periodsSwapStates[\\n                address(order.sellToken)\\n            ][address(order.buyToken)][period];\\n            uint256 periodSwapAmount = (periodSwapState.exchangeRate *\\n                order.amountPerSwap) / 1e27;\\n            uint256 fee = (periodSwapAmount * periodSwapState.feeNumerator) /\\n                FEE_DENOMINATOR;\\n            amountToWithdraw += periodSwapAmount - fee;\\n        }\\n    }\\n\\n    function getCurrentPeriod() public view returns (uint256 period) {\\n        period = block.number / BLOCKS_PER_DAY;\\n    }\\n\\n    function getUserOrders(address userAddress)\\n        external\\n        view\\n        returns (UserOrder[] memory)\\n    {\\n        return orders[userAddress];\\n    }\\n\\n    function getUserOrder(address userAddress, uint256 index)\\n        external\\n        view\\n        returns (UserOrder memory)\\n    {\\n        return orders[userAddress][index];\\n    }\\n\\n    function getSwapState(address sellToken, address buyToken)\\n        external\\n        view\\n        returns (SwapState memory)\\n    {\\n        return swapStates[sellToken][buyToken];\\n    }\\n\\n    function getPeriodSwapState(\\n        address sellToken,\\n        address buyToken,\\n        uint256 period\\n    ) external view returns (PeriodSwapState memory) {\\n        return periodsSwapStates[sellToken][buyToken][period];\\n    }\\n}\\n\",\"keccak256\":\"0x3023141560be65b546c0ed324c4581eef900d07bb4f0f9949fad9f1d2d47ae3d\",\"license\":\"BUSL-1.1\"},\"contracts/DCAClaimer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./DCA.sol\\\";\\n\\ncontract DCAClaimer is Ownable {\\n    function claimSwappedAmounts(\\n        DCA dca,\\n        address[] calldata userAddresses,\\n        uint256[] calldata indexes\\n    ) external returns (bool[] memory) {\\n        require(\\n            userAddresses.length == indexes.length,\\n            \\\"DCAClaimer: Array sizes must match\\\"\\n        );\\n        bool[] memory isCompleted = new bool[](userAddresses.length);\\n\\n        for (uint256 index = 0; index < userAddresses.length; index++) {\\n            DCA.UserOrder memory order = dca.getUserOrders(\\n                userAddresses[index]\\n            )[indexes[index]];\\n            (, uint256 lastSwapPeriod) = dca.swapStates(\\n                address(order.sellToken),\\n                address(order.buyToken)\\n            );\\n            uint256 finalPeriod = order.startingPeriod +\\n                order.numberOfSwaps -\\n                1;\\n            isCompleted[index] = finalPeriod <= order.lastPeriodWithdrawal;\\n\\n            if (\\n                lastSwapPeriod > order.lastPeriodWithdrawal &&\\n                !isCompleted[index]\\n            ) {\\n                dca.withdrawSwapped(userAddresses[index], indexes[index]);\\n            }\\n        }\\n\\n        return isCompleted;\\n    }\\n\\n    /// Shouldn't be necessary, just in case of emergency\\n    function emergency(IERC20 token) external onlyOwner {\\n        require(\\n            token.transfer(msg.sender, token.balanceOf(address(this))),\\n            \\\"DCAClaimer: Emergency withdrawal failed\\\"\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xfd374b7c94d7e1e9002ffd40ac2dafd54dd92306057154f074e6821af53ce8fc\",\"license\":\"MIT\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface Oracle {\\n    function consult(\\n        address tokenIn,\\n        uint256 amountIn,\\n        address tokenOut\\n    ) external view returns (uint256 amountOut);\\n}\\n\",\"keccak256\":\"0x00808b842e95a6c63365936c05d804d5f82a752b6541b95b5c8763b56eb78142\",\"license\":\"MIT\"},\"contracts/interfaces/ISwapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ISwapper {\\n    function swap(\\n        address _sellToken,\\n        address _buyToken,\\n        uint256 _inAmount,\\n        uint256 _outAmount,\\n        bytes calldata _params\\n    ) external;\\n}\\n\",\"keccak256\":\"0xa7084b5a2809672c9a513ea7f22e1c47af7c0320d5575ded394383e8c9faa0bf\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080806040523461005b5760008054336001600160a01b0319821681178355916001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09084a3610dee90816100618239f35b600080fdfe60806040526004361015610013575b600080fd5b6000803560e01c90816345941ee01461007a57508063715018a6146100715780638da5cb5b1461006857806391d70d431461005f5763f2fde38b1461005757600080fd5b61000e610777565b5061000e610396565b5061000e6102d5565b5061000e610230565b34610204576020807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102005780826101879261016d6004356100bf81610207565b73ffffffffffffffffffffffffffffffffffffffff906100e382865416331461086d565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529116908381602481855afa9081156101f3575b85916101c6575b506040517fa9059cbb000000000000000000000000000000000000000000000000000000008152336004820152602481019190915293849283919082906044820190565b03925af19182156101b9575b849261018c575b5050610d2d565b604051f35b6101ab9250803d106101b2575b6101a38183610a39565b810190610d15565b8380610180565b503d610199565b6101c1610c87565b610179565b6101e69150843d86116101ec575b6101de8183610a39565b810190610d06565b88610129565b503d6101d4565b6101fb610c87565b610122565b5080fd5b80fd5b73ffffffffffffffffffffffffffffffffffffffff81160361000e57565b600091031261000e57565b503461000e576000807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102045780547fffffffffffffffffffffffff000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff8216916102a733841461086d565b16825581604051917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08284a3f35b503461000e5760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e57602073ffffffffffffffffffffffffffffffffffffffff60005416604051908152f35b9181601f8401121561000e5782359167ffffffffffffffff831161000e576020808501948460051b01011161000e57565b6020908160408183019282815285518094520193019160005b828110610380575050505090565b8351151585529381019392810192600101610372565b503461000e576060807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e57600480356103d481610207565b67ffffffffffffffff9260243584811161000e576103f59036908501610328565b93909460443590811161000e576104129095939536908301610328565b610420818798939814610941565b61042986610aa1565b9573ffffffffffffffffffffffffffffffffffffffff60009316925b81811061045e576040518061045a8a82610359565b0390f35b61047161046c82848a610b8a565b610ba2565b906104f68a6104cf838760006040978c895195869283927f63c69f08000000000000000000000000000000000000000000000000000000008452830191909173ffffffffffffffffffffffffffffffffffffffff6020820193169052565b03818d5afa92831561076a575b600093610745575b506104ef9293610b8a565b3590610c94565b51610531610518825173ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1690565b908a838a8661055a610518602087015173ffffffffffffffffffffffffffffffffffffffff1690565b81517f1709945a00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9788168e82019081529190971660208201528690819060400103818d5afa948515610738575b6000956106f0575b506105fc929160a06105e86105e36105f59460808901519089015190610ccc565b610cd8565b9501948551101592610c94565b9015159052565b5110806106d0575b610618575b6106139150610b20565b610445565b61062661046c82858b610b8a565b61063182868d610b8a565b3592863b1561000e57517f295d056600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff909116878201908152602081019390935261061392600090829081906040010381838a5af180156106c3575b6106aa575b50610609565b806106b76106bd926109fc565b80610225565b386106a4565b6106cb610c87565b61069f565b506106eb6106e76106e1838c610c94565b51151590565b1590565b610604565b6105f59195509160a06105e86105e36107226105fc97968c8d3d10610731575b61071a8183610a39565b810190610cb6565b905098945050505091926105c2565b503d610710565b610740610c87565b6105ba565b610764906104ef943d8091833e61075c8183610a39565b810190610baf565b926104e4565b610772610c87565b6104dc565b503461000e5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e576004356107b381610207565b73ffffffffffffffffffffffffffffffffffffffff6107d78160005416331461086d565b8116156107e9576107e7906108d2565b005b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b1561087457565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b6000549073ffffffffffffffffffffffffffffffffffffffff80911691827fffffffffffffffffffffffff0000000000000000000000000000000000000000821617600055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e06000604051a3565b1561094857565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f444341436c61696d65723a2041727261792073697a6573206d757374206d617460448201527f63680000000000000000000000000000000000000000000000000000000000006064820152fd5b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b67ffffffffffffffff8111610a1057604052565b610a186109cc565b604052565b60c0810190811067ffffffffffffffff821117610a1057604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610a1057604052565b60209067ffffffffffffffff8111610a94575b60051b0190565b610a9c6109cc565b610a8d565b90610aab82610a7a565b610ab86040519182610a39565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0610ae68294610a7a565b0190602036910137565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6001907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610b4e570190565b610b56610af0565b0190565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9190811015610b9a5760051b0190565b610a9c610b5a565b35610bac81610207565b90565b602090818184031261000e5780519067ffffffffffffffff821161000e570182601f8201121561000e57805191610be583610a7a565b936040610bf481519687610a39565b848652828601918360c08097028601019481861161000e578401925b858410610c21575050505050505090565b868483031261000e578487918451610c3881610a1d565b8651610c4381610207565b815282870151610c5281610207565b838201528587015186820152606080880151908201526080808801519082015260a08088015190820152815201930192610c10565b506040513d6000823e3d90fd5b6020918151811015610ca9575b60051b010190565b610cb1610b5a565b610ca1565b919082604091031261000e576020825192015190565b81198111610b4e570190565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9060018110610b4e570190565b9081602091031261000e575190565b9081602091031261000e5751801515810361000e5790565b15610d3457565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f444341436c61696d65723a20456d657267656e6379207769746864726177616c60448201527f206661696c6564000000000000000000000000000000000000000000000000006064820152fdfea2646970667358221220341f8d93fae409982bc4f372f0490666125e444ea2eb68f791e653a49e8d196264736f6c634300080d0033",
  "deployedBytecode": "0x60806040526004361015610013575b600080fd5b6000803560e01c90816345941ee01461007a57508063715018a6146100715780638da5cb5b1461006857806391d70d431461005f5763f2fde38b1461005757600080fd5b61000e610777565b5061000e610396565b5061000e6102d5565b5061000e610230565b34610204576020807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102005780826101879261016d6004356100bf81610207565b73ffffffffffffffffffffffffffffffffffffffff906100e382865416331461086d565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529116908381602481855afa9081156101f3575b85916101c6575b506040517fa9059cbb000000000000000000000000000000000000000000000000000000008152336004820152602481019190915293849283919082906044820190565b03925af19182156101b9575b849261018c575b5050610d2d565b604051f35b6101ab9250803d106101b2575b6101a38183610a39565b810190610d15565b8380610180565b503d610199565b6101c1610c87565b610179565b6101e69150843d86116101ec575b6101de8183610a39565b810190610d06565b88610129565b503d6101d4565b6101fb610c87565b610122565b5080fd5b80fd5b73ffffffffffffffffffffffffffffffffffffffff81160361000e57565b600091031261000e57565b503461000e576000807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102045780547fffffffffffffffffffffffff000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff8216916102a733841461086d565b16825581604051917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08284a3f35b503461000e5760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e57602073ffffffffffffffffffffffffffffffffffffffff60005416604051908152f35b9181601f8401121561000e5782359167ffffffffffffffff831161000e576020808501948460051b01011161000e57565b6020908160408183019282815285518094520193019160005b828110610380575050505090565b8351151585529381019392810192600101610372565b503461000e576060807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e57600480356103d481610207565b67ffffffffffffffff9260243584811161000e576103f59036908501610328565b93909460443590811161000e576104129095939536908301610328565b610420818798939814610941565b61042986610aa1565b9573ffffffffffffffffffffffffffffffffffffffff60009316925b81811061045e576040518061045a8a82610359565b0390f35b61047161046c82848a610b8a565b610ba2565b906104f68a6104cf838760006040978c895195869283927f63c69f08000000000000000000000000000000000000000000000000000000008452830191909173ffffffffffffffffffffffffffffffffffffffff6020820193169052565b03818d5afa92831561076a575b600093610745575b506104ef9293610b8a565b3590610c94565b51610531610518825173ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1690565b908a838a8661055a610518602087015173ffffffffffffffffffffffffffffffffffffffff1690565b81517f1709945a00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9788168e82019081529190971660208201528690819060400103818d5afa948515610738575b6000956106f0575b506105fc929160a06105e86105e36105f59460808901519089015190610ccc565b610cd8565b9501948551101592610c94565b9015159052565b5110806106d0575b610618575b6106139150610b20565b610445565b61062661046c82858b610b8a565b61063182868d610b8a565b3592863b1561000e57517f295d056600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff909116878201908152602081019390935261061392600090829081906040010381838a5af180156106c3575b6106aa575b50610609565b806106b76106bd926109fc565b80610225565b386106a4565b6106cb610c87565b61069f565b506106eb6106e76106e1838c610c94565b51151590565b1590565b610604565b6105f59195509160a06105e86105e36107226105fc97968c8d3d10610731575b61071a8183610a39565b810190610cb6565b905098945050505091926105c2565b503d610710565b610740610c87565b6105ba565b610764906104ef943d8091833e61075c8183610a39565b810190610baf565b926104e4565b610772610c87565b6104dc565b503461000e5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e576004356107b381610207565b73ffffffffffffffffffffffffffffffffffffffff6107d78160005416331461086d565b8116156107e9576107e7906108d2565b005b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b1561087457565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b6000549073ffffffffffffffffffffffffffffffffffffffff80911691827fffffffffffffffffffffffff0000000000000000000000000000000000000000821617600055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e06000604051a3565b1561094857565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f444341436c61696d65723a2041727261792073697a6573206d757374206d617460448201527f63680000000000000000000000000000000000000000000000000000000000006064820152fd5b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b67ffffffffffffffff8111610a1057604052565b610a186109cc565b604052565b60c0810190811067ffffffffffffffff821117610a1057604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610a1057604052565b60209067ffffffffffffffff8111610a94575b60051b0190565b610a9c6109cc565b610a8d565b90610aab82610a7a565b610ab86040519182610a39565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0610ae68294610a7a565b0190602036910137565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6001907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610b4e570190565b610b56610af0565b0190565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9190811015610b9a5760051b0190565b610a9c610b5a565b35610bac81610207565b90565b602090818184031261000e5780519067ffffffffffffffff821161000e570182601f8201121561000e57805191610be583610a7a565b936040610bf481519687610a39565b848652828601918360c08097028601019481861161000e578401925b858410610c21575050505050505090565b868483031261000e578487918451610c3881610a1d565b8651610c4381610207565b815282870151610c5281610207565b838201528587015186820152606080880151908201526080808801519082015260a08088015190820152815201930192610c10565b506040513d6000823e3d90fd5b6020918151811015610ca9575b60051b010190565b610cb1610b5a565b610ca1565b919082604091031261000e576020825192015190565b81198111610b4e570190565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9060018110610b4e570190565b9081602091031261000e575190565b9081602091031261000e5751801515810361000e5790565b15610d3457565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f444341436c61696d65723a20456d657267656e6379207769746864726177616c60448201527f206661696c6564000000000000000000000000000000000000000000000000006064820152fdfea2646970667358221220341f8d93fae409982bc4f372f0490666125e444ea2eb68f791e653a49e8d196264736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "emergency(address)": {
        "notice": "Shouldn't be necessary, just in case of emergency"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7,
        "contract": "contracts/DCAClaimer.sol:DCAClaimer",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      }
    }
  }
}